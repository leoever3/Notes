### Java Memory Management

* Java has automatic memory management. It automatically performs **garbage collection**.
* **Garbage**: class objects which are instantiated but not in use anymore.
* **OutofMemoryError**

#### Memory Structure in Java

* **Stack**
  * stores Java **primitive** types(int, char...)	Primitive types don't have reference to an object
  * holds a **reference** to heap objects
* **Heap**
  * **Actual** object will be stored in this part of memory.
  * The objects their reference is located inside **stack**, their value inside the **heap**

##### <u>Stack & Heap</u>

* **Stack**
  * The **size of the stack is flexible** and changes as methods and functions create or delete local variables.
  * **Memory allocation** (assignment and freeing) is **automatic**, without a need for code.
  * Stack has **size limits** varying from operating system that host JVM.
  * Variable inside the stack remain there as long as **the function that created them is running**.
  * If stack space is full, Java throws **java.lang.StackOverFlow**
  * **Restart the JVM**.
* **Heap**
  * **Not managed automatically**, need to free allocated memory **by code** when memory blocks are no longer needed.
  * The heap is prone to **memory leak** problems, where memory is allocated to unused objects and will not be available to processes other than that.
  * **No size limit** in the heap
  * Heap is **slower** to write or read than stack.
  * If heap space is full, Java throws java.lang.OutofMemoryError.
  * **Set the variable to null**.
  * Only one heap memory for JVM process. Heap is shared part of memory for all the threads.

We can configue maximum stack and heap size.

#### <u>Memory Reference Types</u>

* **Strong:** When there is a **direct** reference to an object and it is not eligible for garbage collection.

```java
Test obj = new Test()
```

* **Weak:** When an object has neither strong nor soft reference, it is a weak reference. Weak references should be explicitly specified while referencing them.

```java
// Strong Reference
Test a = **new** Test();
a.x();
// Creating Weak Reference to Test object to which ‘a’is also pointing.
WeakReference<Test> weakref = new WeakReference<Test>(a);
```

* **Soft:** When an object is free for garbage collection, but it is **not yet garbag**e collected, until JVM is running low on memory and looking for objects to remove.

```java
 // Marked for gc, but JVM might not do it immediately.
 g = null;
```

* **Phantom:** Objects are eligible for GC, but JVM puts them in a queue called “**ReferenceQueue**”. We don’t know a phantom referenced object is dead or alive.

### Algorithm Complexity

#### Big O notation

* **Magnitude** of performance
* **Worst-case** response time

**O(1)**—constant time:** It doesn’t matter how large the data is, the answer will always take the same time to return.

**O(n)**—linear time:** The performance will grow linearly with respect to the size of the collection. Looping through a list and returning the number of elements matching “Panda” will take linear time.

**O(n log n)**—logarithmic time:** A logarithm is a mathematical function that grows much more slowly than the data size. Binary search runs in logarithmic time because it doesn’t look at the majority of the elements for large collections.

**O(n2)—n squared time:** Code that has nested loops where each loop goes through the data takes *n* squared time. An example would be putting every pair of pandas together to see if they’ll share an exhibit.

![image-20211202190814099](/Users/morningstar/Library/Application Support/typora-user-images/image-20211202190814099.png)

