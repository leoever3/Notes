### Thread

* Problem:  slow disk access 
* Resolve: **multi-thread** feature --- **concurrency**
* Thread is the smallest unit of execution that can be scheduled by the operating system.
* Task -> thread -> process
  * Single core CPU --- only one thread
  * Multi core CPU ---lareger than the number of cores
* Operating systems are using **thread scheduler** which decide what should be executed. 
  * Robin algorithm

![image-20211203144820380](/Users/morningstar/Library/Application Support/typora-user-images/image-20211203144820380.png)

* Thread Priority

#### Runnable

* Java.lang.Runnable is a **functional java interface** that is used to define the work that a thread should execute.

* A functional interface is an interface that contains only **one abstract method**, but it can have any number of non-abstract methods.

```java
@FunctionalInterface
 public interface Runnable {
     void run();
}
```

#### Create threads

```java
public class ThreadExample implements Runnable {
  public void run(){
    // what is running inside the thread goes here
	} 
}
public class TestThread {
	public static void main(String[] args) {
		FirstThread firstT = new FirstThread() ;
		Thread a = new Thread(firstT);
		SecondThread secondT = new SecondThread();
		Thread b = new Thread(secondT);
		a.start();
		try {
			a.join();
		} catch (Exception e) {
			e.printStackTrace();
		}
		b.start();
	}
}
```

#### Summary

* Thread is a class
* Runnable is an **interface**
* The thread class **implements** Runnable
* The argument passed to the thread constructor must be a Runable

```java
Thread t = new Thread(new SuperSimplePrint());
```

* The threads spawned by a process run asynchronously

##### Run() VS start()

* Start() will starts a new thread and the JVM assigns it to a CPU core
* Run() will execute the content of a thread

#### Questions in Job Interview

##### <u>Extending the Thread class & implementing Runnable</u>

* If we need to define our own thread rules, e.g. a **priority thread**, extending thread may be preferable

* Extending Thread does not allow us to extend any other class, whereas **implementing runnable** lets you extend another class.
* **Implementing Runnable** is often a better object-oriented design practice, because it **separates the task being performed from the Thread object that are performing it.**

#### Methods

* `join()` Waits for this thread to die.
* `sleep()` causes a thread to pauses its execution for x milliseconds.

### Locks

#### Structured lock

* **synchronize**: imposes a lock

```java
synchronized void increment(val){ 
	val = val+1
}
```

**Disadvantage**:

We disable the multi tasking features, which might increase response time.

performance bottleneck of a system

* Atomic

#### Unstructured lock

* ReentrantLock(Interface lock or Try lock)
* Read/Write lock

#### <u>Semantic erros in concurrency</u>

* DeadLock

![image-20211203163743235](/Users/morningstar/Library/Application Support/typora-user-images/image-20211203163743235.png)

* Live lock

![image-20211203163805567](/Users/morningstar/Library/Application Support/typora-user-images/image-20211203163805567.png)

* Starvation

![image-20211203163923966](/Users/morningstar/Library/Application Support/typora-user-images/image-20211203163923966.png)

This usually happens in read read/write locks. We do lots of read threads and write threads are getting starved.